%% DESCRIPTION OF THE CODE
\section{Description of the code}

Gradus.jl is implemented in Julia, but makes itself available via popular package managers to a wide variety of languages, including Python via \texttt{pip}.

Gradus.jl aims to have a single expressive high-level API for a variety of GRRT problems, with sensible defaults and optional fine-grained control. The code is accompanied by both code-level and HTML-generated documentation\footnote{\url{https://astro-group-bristol.github.io/Gradus.jl/dev/}}, with short tutorials and examples designed to provide a feature-rich overview whilst simultaneously demonstrating how to construct custom simulations and how to integrate Gradus.jl in a user's model. We encourage readers who are interesting in learning up-to-date information and method in our codes to consult the documentation over this paper. 

The documentation strives to be the most accurate description of the code as it is maintained, detailing algorithm specific choices and implementations, and is built as part of our continuous deployment (CD). The source code is written to be read by contributors and users alike to invite extension, and to be explicit about our methods, their benefits, and limitations.

The code makes use of Julia's heterogeneity and concurrency to run in multi-threaded and distributed environments, with GPU-offloading via DiffEqGPU.jl and CUDA.jl\footnote{We note that GPU acceleration is currently limited due to a combination of ODE callbacks and `warp' termination. Progress in resolving outstanding problems is being tracked as an issue.}. Gradus.jl is performant enough to create simulation products on personal computers\footnote{E.g., recomputing all 600 \texttt{relline} transfer function tables \cite{} on a 2021 Apple 8-core M1 Macbook takes approximately 2 hours.}, but scales effortlessly to supercomputers.

Precision is user-defined and inferred from user provided types. Single precision floating point arithmetic may be desirable for GPU computing, whereas `big float' precision may be needed for some extreme near-horizon computations. In our discussion of the numerical methods, we note the current default algorithm is Tsitouras Runge-Kutta 5/4. Gradus.jl vendors many additional ODE solvers and numerical algorithms from the Julia SciML ecosystem, that may be used when certain integrations or problems require them.

Gradus.jl provides a number of predefined metrics, including the Kerr spacetime, Morris-Thorne wormhole, Johannsen-Psaltis, Dilaton-Axion, and a modified Kerr with coronal refraction. The Kerr-Newman metric is also implemented, complete with the ability to specify the electromagnetic potential vector, from which external forces in \eqref{eq:geodesic_equation} are calculated. Furthermore, Gradus.jl allows for 1st order specification of the geodesic ODE system, primarily used as a point of comparison with the second order results.

For Julia, AD is implemented in the ForwardDiff.jl package \citep{RevelsLubinPapamarkou2016}

Multi-threaded, multi-CPU, optionally GPU decelerated. Speedup depends on choice of solver (fixed time step faster on GPU)

List of currently implemented metrics

Adding new spacetimes

Accretion disc geometries

Point functions for composable results

Performance vs e.g. Bambi's NK and other work

\subsection{Simulation products}

What we can export, and how they can be exported / used in e.g. XSPEC

