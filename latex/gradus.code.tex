%% DESCRIPTION OF THE CODE
\section{Description of the code}

\Gradus is implemented in the Julia programming language \citep{Bezanson_Julia_A_fresh_2017}. We use the DifferentialEquations.jl ODE solving library and ForwardDiff.jl for forward-mode automatic differentiation \citep{RevelsLubinPapamarkou2016}. The code is available via the \texttt{Pkg} Julia package manger in a registry maintained by members of the University of Bristol astrophysics group\footnote{\url{https://github.com/astro-group-bristol/AstroRegistry/}}. There are also rudimentary bindings to a wide variety of languages, including Python via \texttt{pip} \citep{}.

\Gradus aims to have a single expressive high-level API for a variety of GRRT problems, with sensible defaults and optional fine-grained control. The code is accompanied by website documentation\footnote{\url{https://astro-group-bristol.github.io/Gradus.jl/}}, with short tutorials and examples designed to provide a feature-rich overview whilst simultaneously demonstrating how to construct custom simulations and how to integrate \Gradus in user models. We encourage readers who are interesting in learning up-to-date information about the code and our methods to consult the documentation, as the documentation strives to be the most accurate description of the code as it is maintained. The documentation details all algorithm specific choices and implementations, and is built as part of our continuous integration (CI). The source code is written to be read by contributors and users alike to invite extension, to be explicit about our methods, and their benefits and limitations.

\Gradus is extensively tested with a suite of unit and end-to-end tests. The tests are constructed both by comparing numerical algorithms to specific analytic counterparts, and by saving snapshots of results in the literature to compare against. The development cycle of \Gradus is thereby expedited, allowing changes to the codebase to be made with the confidence that no previous result will be broken.

In our discussion of the numerical methods, we note the current default ODE integration algorithm is Tsitouras Runge-Kutta 5/4. \Gradus vendors additional ODE solvers and numerical algorithms from the Julia SciML ecosystem, with both adaptive and fixed time steps, that may provide performance or accuracy improvements for specific problems.

\Gradus maintains a catalogue of predefined metrics, including the Kerr spacetime, Morris-Thorne wormhole, Johannsen-Psaltis metric, the Einstein-Maxwell Dilaton-Axion metric \todo{citations for these}, and the Kerr-Newman metric, complete with the ability to specify the electromagnetic potential vector, from which external accelerations $a^\mu$ in \eqref{eq:geodesic_equation} are calculated. \Gradus also has limited support for 1st order specification of the geodesic ODE system, where such a system is known. This is implemented for the Kerr spacetime, and used primarily as a self-consistency check with the second-order implementation.

\subsection{Extensibility}

Our implementations of the numerical methods, as well as the actual methods themselves, are conceptually simple and consequently generalize well. The design of \Gradus prioritizes useability and extensibility, which comes at a small performance cost: our aim is not to implement the fastest, semi-analytic solutions to specific problems, but rather to have an optimal and interpretable codebase for exploring problems related to general relativity. The abstractions in \Gradus have been designed to allow users to implement and calculate observables of their models quickly. To this end, we also include a number of visualization and plotting recipes to provide some intuition for the problem space.

\Gradus is designed to allow simple one-line changes to propagate through the simulations. The requisite calculations for determining observables have been abstracted in such a way that the precise function calls are determined at compile-time. This design is possible with Julia's just-in-time compilation and multiple dispatch, and bring additional benefits: different number types may be used through the whole library, permitting arbitrary precision floating point operations, symbolic evaluation through Symbolics.jl \citep{symbolics_julia}, or the propagation of AD gradient information through an entire simulation. Consequently, our code can calculate derivatives of any physical product with respect to the input parameters, and is therefore optimal for use directly in model fitting.

The shim we have implemented between our ODE problems and DifferentialEquations.jl allows additional quantities to be integrated along with the geodesic equation, as described in Section \ref{sec:computing-observables}. The abstraction permits users of \Gradus to easily specify new ODE components to be traced, if their model requires them. Many types in \Gradus are also composable, allowing complex simulations and calculations to be pieced together from simpler, testable components. Analytic accretion geometry may also be simply specified, and mesh geometry in common file formats may be readily imported.

Our transfer function integration routines permit arbitrary kernels, allowing any quantity integrated over the image plane to be efficiently pre-computed and calculated via transfer functions. Where additional information about the geodesics is needed, our extension to include the timing component serves as an example of the methods we have developed to permit this.

\subsection{Performance}
\label{sec:performance}

Our code makes use of Julia's heterogeneity and concurrency to run in multi-threaded and distributed environments, with GPU-offloading via DiffEqGPU.jl \citep{utkarsh2023automated}, and the various supported backends including CUDA and Metal \citep{besard2018juliagpu}. We have developed custom threading contexts that minimize allocated memory when tracing large numbers of geodesics.


\todo{a little talk about the threading strategies etc.}

\todo{GPU vs CPU and when one is one better than the other
Performance vs e.g. Bambi's NK and other work}

\subsection{Simulation products}

\todo{What we can export, and how they can be exported / used in e.g. XSPEC}

